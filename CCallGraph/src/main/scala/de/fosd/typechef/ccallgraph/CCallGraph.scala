package de.fosd.typechef.ccallgraph

import de.fosd.typechef.conditional._
import de.fosd.typechef.featureexpr.FeatureExprFactory.{False, True}
import de.fosd.typechef.featureexpr.{FeatureExpr, FeatureExprFactory, FeatureModel}
import de.fosd.typechef.parser.c._

/**
 * Created by gferreir on 9/20/14.
 *
 */

class CCallGraph {

  type ObjectName = String
  type Scope = String
  type Assignment = (ObjectName, ObjectName)
  type FunctionName = String

  // source, target
  type FunctionCall = (String, String)

  // name, kind, source code line
  type FunctionDef = (String, String, Int)

  // debug flag - prints AST details
  def DEBUG = false

  var callGraphNodes: ConditionalSet[Node] = ConditionalSet()
  var callGraphEdges: ConditionalSet[Edge] = ConditionalSet()

  var objectNames: ConditionalSet[ObjectName] = ConditionalSet()
  var equivalenceClasses: Set[EquivalenceClass] = Set()
  private var objectNameAssignments: ConditionalSet[Assignment] = ConditionalSet()
  private var equivalenceClassesPrefixSets: Set[(ObjectName, ObjectName)] = Set()

  // map of function defs and [return values, parameters]
  var functionDefs: ConditionalSet[FunctionDef] = ConditionalSet()
  var functionDefReturns: Map[FunctionName, ConditionalSet[ObjectName]] = Map()
  var functionDefParameters: Map[FunctionName, List[Opt[ObjectName]]] = Map()

  var functionCallParamList: List[Opt[ObjectName]] = List()

  // function calls and function call parameters
  private var functionCalls: ConditionalSet[FunctionCall] = ConditionalSet()
  private var functionCallParameters: List[(FunctionName, List[Opt[ObjectName]])] = List()

  // object names scope (key =  object name, value = scope)
  private var objectNamesScope: Map[ObjectName, Scope] = Map()

  // context variables
  private var currentFunction: Scope = "GLOBAL"
  private var currentFunctionKind: String = "function"
  private var currentDeclarator: ObjectName = ""
  private var currentDeclaratorLine: Int = -1
  private var isDeclarationStatement: FeatureExpr = False
  private var isPointer: FeatureExpr = False
  private var isFunctionDef: FeatureExpr = False
  private var isNotTypedefSpecifier: FeatureExpr = True
  private var isFunctionDeclarator: FeatureExpr = False

  def extractCallGraph() = {
    extractNodes() // function defs
    extractEdges() // function calls
  }

  def extractNodes() = {
    functionDefs.toPlainSetWithConditionals().map({ case ((name, kind, sourceCodeLine), featExpr) => callGraphNodes +=(Node(name, kind, sourceCodeLine), featExpr) })
  }

  def extractEdges() = {
    var found: Boolean = false
    for (((source, target), featExpr) <- functionCalls.toPlainSetWithConditionals()) {
      // handles function names generated by ConditionalExpr
      var functionTargets = target.split("\\|").filterNot({ s => s.equals("Empty") })

      for (functionTarget <- functionTargets) {
        // checks if the function call target is not defined (if object name is not a function name)
        if (!functionDefs.toPlainSet().map({ case (name, _, _) => name }).contains(unscope(functionTarget))) {

          // search for equivalence class that contains the function call target
          var pointerEquivalanceClass = equivalenceClasses.find({ e => e.unscopedObjectNames().contains(functionTarget) })
          if (!pointerEquivalanceClass.isDefined) {
            pointerEquivalanceClass = equivalenceClasses.find({ e => e.unscopedObjectNames().contains("%s()".format(functionTarget)) })
          }

          // if no equivalence class is found, insert Equiv. Class Not Found edge type. In theory, this should occur only when target (function) is defined in another file)
          // reason: an equivalence class is created for each object name found in the file in the beginning of the analysis
          if (!pointerEquivalanceClass.isDefined) {
            callGraphEdges +=(Edge(source, functionTarget, EdgeKind.EquivalenceClassNotFound.toString), featExpr)
          } else {
            // add an indirect function call for each function name found in the equivalence class
            found = false
            for ((pointerTarget, pointerFeatExpr) <- pointerEquivalanceClass.get.objectNames.toPlainSetWithConditionals()) {

              // if target is function name
              if (functionDefs.toPlainSet().map({ case (name, _, _) => name }).contains(unscope(pointerTarget))) {
                callGraphEdges +=(Edge(source, unscope(pointerTarget), EdgeKind.Indirect.toString), pointerFeatExpr)
                found = true
              }
            }
            // if no function name was found, insert an Function Name Not Found edge with the original object name. In theory, this could occur in only two situations:
            //   1) we missed pointer assignments and not function name was found at the same pointer equivalence class
            //   2) a function was used without being defined in the file (linking is required)
            if (!found) {
              callGraphEdges +=(Edge(source, functionTarget, EdgeKind.FunctionNameNotFound.toString), featExpr)
            }
          }
        }
        else {
          // add direct function call
          callGraphEdges +=(Edge(source, unscope(functionTarget), EdgeKind.Direct.toString), featExpr)
        }
      }
    }
  }

  def functionKind(specifiers: List[Opt[Specifier]]): String = {
    if (specifiers.map(_.entry).contains(InlineSpecifier())) "function-inline"
    else if (specifiers.map(_.entry).contains(StaticSpecifier())) "function-static"
    else "function"
  }


  def calculatePointerEquivalenceRelation(program: TranslationUnit): Set[EquivalenceClass] = {

    // extract objectNames and their assignments from the AST
    extractObjectNames(program, True)

    // extract program assignments (function call parameters and return values)
    addAssignmentsFromFunctionCallParameters()
    addAssignmentsFromFunctionCallReturnValues()

    // create initial equivalance class for each object name
    initEquivalanceClasses()

    // create edges between initial equivalence classes
    createInitialPrefixSets()

    // for each pointer related assignment, merge prefixes if  different
    for ((assignee, assignor) <- objectNameAssignments.toPlainSet()) {
      mergeEquivalenceClasses(assignee, assignor)
    }
    equivalenceClasses
  }

  def initEquivalanceClasses(): Unit = {
    objectNames.keys.foreach({ k =>
      equivalenceClasses += new EquivalenceClass(ConditionalSet(k, objectNames.get(k)), ConditionalSet())
    })
  }

  def find(objectName: ObjectName): Option[EquivalenceClass] = {
    for (node: EquivalenceClass <- equivalenceClasses) {
      if ((node.objectNames.contains(objectName)).isSatisfiable() || (node.objectNames.contains(parenthesize(objectName))).isSatisfiable()) {
        return Some(node)
      }
    }
    None
  }


  def addPrefixSet(o1: ObjectName, o2: ObjectName) = {
    equivalenceClassesPrefixSets += ((o1, o2))
  }

  def createInitialPrefixSets(): Unit = {
    var eqClassObjectO: EquivalenceClass = EquivalenceClass()
    var eqClassObjectO1: EquivalenceClass = EquivalenceClass()
    // generate cross product of all object names
    for ((o, o1) <- equivalenceClassesPrefixSets) {
      val findObjectNameO = find(o)
      val findObjectNameO1 = find(o1)

      if (findObjectNameO.isDefined && findObjectNameO1.isDefined) {
        eqClassObjectO = findObjectNameO.get
        eqClassObjectO1 = findObjectNameO1.get

        val eqClassObjectOFeatExpr = eqClassObjectO.objectNames.get(o)
        val eqClassObjectO1FeatExpr = eqClassObjectO1.objectNames.get(o1)

        val uo = unscope(o)
        val uo1 = unscope(o1)

        // pointer cretion operator
        if ((uo.equals(apply(ObjectNameOperator.PointerCreation.toString, uo1))) || uo.equals(apply(ObjectNameOperator.PointerCreation.toString, parenthesize(uo1))) && eqClassObjectOFeatExpr.and(eqClassObjectO1FeatExpr).isSatisfiable()) {
          // add * edge from o to o1 (removing the pointer creation effect with a dereferencing operator)
          eqClassObjectO.addPrefix((ObjectNameOperator.PointerDereference.toString, o1), eqClassObjectOFeatExpr and eqClassObjectO1FeatExpr)

          // pointer dereference operator
        } else if ((uo.equals(apply(ObjectNameOperator.PointerDereference.toString, uo1)) || uo.equals(apply(ObjectNameOperator.PointerDereference.toString, parenthesize(uo1))) && (eqClassObjectOFeatExpr.and(eqClassObjectO1FeatExpr).isSatisfiable()))) {
          // add * edge from o1 to o
          eqClassObjectO1.addPrefix((ObjectNameOperator.PointerDereference.toString, o), eqClassObjectOFeatExpr and eqClassObjectO1FeatExpr)

          // struct dot access operator
        } else if ((uo.startsWith(apply(ObjectNameOperator.StructAccess.toString, uo1)) || uo.startsWith(apply(ObjectNameOperator.StructAccess.toString, parenthesize(uo1))) && (eqClassObjectOFeatExpr.and(eqClassObjectO1FeatExpr).isSatisfiable()))) {
          val objectNameFields = (uo.take(uo.lastIndexOf(ObjectNameOperator.StructAccess.toString)), uo.drop(uo.lastIndexOf(ObjectNameOperator.StructAccess.toString) + ObjectNameOperator.StructAccess.toString.length))
          val eqClassObjectOPartial = find(objectNameFields._1)

          // add field edge from o to o1
          if (eqClassObjectOPartial.isDefined) {
            eqClassObjectOPartial.get.addPrefix((objectNameFields._2, o), eqClassObjectOFeatExpr and eqClassObjectO1FeatExpr)

          }

          // struct pointer access operator  (dereference + dot)
        } else if ((uo.startsWith(apply(ObjectNameOperator.StructPointerAccess.toString, uo1)) || uo.startsWith(apply(ObjectNameOperator.StructPointerAccess.toString, parenthesize(uo1))) && (eqClassObjectOFeatExpr.and(eqClassObjectO1FeatExpr).isSatisfiable()))) {
          val objectNameFields = (uo.take(uo.lastIndexOf(ObjectNameOperator.StructPointerAccess.toString)), uo.drop(uo.lastIndexOf(ObjectNameOperator.StructPointerAccess.toString) + ObjectNameOperator.StructPointerAccess.toString.length))
          val eqClassObjectOPartial = find(apply(ObjectNameOperator.PointerDereference.toString, objectNameFields._1))

          // add field edge from o to o1
          if (eqClassObjectOPartial.isDefined) {
            eqClassObjectOPartial.get.addPrefix((objectNameFields._2, o), eqClassObjectOPartial.get.objectNames.get(o) and eqClassObjectO1FeatExpr)
          }
        }
        eqClassObjectO.objectNames = eqClassObjectO.objectNames.and(o, eqClassObjectOFeatExpr and eqClassObjectO1FeatExpr)
        eqClassObjectO1.objectNames = eqClassObjectO1.objectNames.and(o1, eqClassObjectO1FeatExpr and eqClassObjectOFeatExpr)


      }
      else {
        println(">>> One or both object names are not defined: %s / %s".format(o, o1))
      }
    }
  }

  def apply(operator: String, objectName: String): String = {
    ObjectNameOperator.withName(operator) match {
      // suffix operators
      case ObjectNameOperator.StructAccess | ObjectNameOperator.StructPointerAccess => "%s%s".format(objectName, operator)
      // prefix operators
      case ObjectNameOperator.PointerCreation | ObjectNameOperator.PointerDereference => "%s%s".format(operator, objectName)
    }
  }

  def unscope(scopedObjectName: String): String = {
    scopedObjectName.replaceFirst("[a-zA-Z0-9_]+?\\$", "")
  }


  def addAssignmentsFromFunctionCallParameters() = {
    for ((function, listParams) <- functionCallParameters) {

      val listParamsFuncDef: Conditional[List[ObjectName]] = ConditionalLib.explodeOptList(functionDefParameters.getOrElse(function, List()))
      val listParamsFuncCal: Conditional[List[ObjectName]] = ConditionalLib.explodeOptList(listParams)

      val assignments = ConditionalLib.explode(listParamsFuncCal, listParamsFuncDef).toList

      assignments.foreach({ t =>
        val expr = t._1
        val (list1, list2) = t._2
        val condAssignments = list1.zip(list2)

        condAssignments.foreach({ a => objectNameAssignments +=(a, expr) })
      })
    }
  }

  // replace each auxiliary function call reference for its real return values
  def addAssignmentsFromFunctionCallReturnValues() = {
    val assignmentsPartition = objectNameAssignments.partition({ a: ((String, String)) => !a._1.contains(ObjectNameOperator.FunctionCall.toString) && !a._2.contains(ObjectNameOperator.FunctionCall.toString) })
    var normalizedAssignments: ConditionalSet[Assignment] = assignmentsPartition._1

    // replace function call by the all return values
    assignmentsPartition._2.toPlainSetWithConditionals().foreach({ case (assign, featExpr) =>
      if (assign._1 contains ObjectNameOperator.FunctionCall.toString) {
        functionDefReturns.getOrElse(unscope(assign._1.replaceAll("\\(\\)", "")), ConditionalSet()).toPlainSetWithConditionals().foreach({
          x => normalizedAssignments +=((x._1, assign._2), featExpr and x._2)
        })
      } else if (assign._2 contains ObjectNameOperator.FunctionCall.toString) {
        functionDefReturns.getOrElse(unscope(assign._2.replaceAll("\\(\\)", "")), ConditionalSet()).toPlainSetWithConditionals().foreach({
          x => normalizedAssignments +=((x._1, assign._1), featExpr and x._2)
        })
      }
    })
    objectNameAssignments = normalizedAssignments
  }

  def mergeEquivalenceClasses(assignee: ObjectName, assignor: ObjectName) {
    val eqClassAssignee = find(assignee)
    val eqClassAssignor = find(assignor)

    if (eqClassAssignee.isDefined && eqClassAssignor.isDefined && !eqClassAssignee.equals(eqClassAssignor)) {
      eqClassAssignee.get.beingMerged = true
      eqClassAssignor.get.beingMerged = true
      merge(eqClassAssignee.get, eqClassAssignor.get)
      eqClassAssignee.get.beingMerged = false
      eqClassAssignor.get.beingMerged = false
    }
  }

  def merge(e1: EquivalenceClass, e2: EquivalenceClass) {
    val newObjectNamesSet: EquivalenceClass = e1.union(e2)
    var newPrefixSet: ConditionalSet[(String, String)] = e1.prefixes()

    // loop both prefix sets
    for ((a, o) <- e2.prefixes().toPlainSet()) {
      // filter prefixes shared by the two eq classes
      val sharedPrefix = newPrefixSet.toPlainSet().filter({ case (a1, o1) => a.equals(a1) })

      // if equivalence classes share the same prefix (i.e., if they have edges to the same object name)
      if (sharedPrefix.nonEmpty) {
        sharedPrefix.map({ case ((_, o1)) =>
          val eqClassO = find(o)
          val eqClassO1 = find(o1)

          // if any two eq classes have the same prefix relation, merge them recursively
          if (eqClassO.isDefined && eqClassO1.isDefined && !eqClassO.get.beingMerged && !eqClassO1.get.beingMerged && !eqClassO.equals(eqClassO1)) {
            merge(eqClassO.get, eqClassO1.get);
          }
          // TODO: check why equivalent classes did not merge
        })
      } else newPrefixSet +=((a, o), e2.prefixes().get((a, o)))
    }
    // add new equivalence class and delete merged ones
    equivalenceClasses -=(e1, e2)
    equivalenceClasses += new EquivalenceClass(newObjectNamesSet.objectNames, newPrefixSet)

  }

  def addObjectName(scopedObjectName: ObjectName, ctx: FeatureExpr): ObjectName = {
    // add object name with scope defined
    objectNames = objectNames +(scopedObjectName, ctx)
    scopedObjectName
  }

  def applyScope(objectName: ObjectName, currentScope: Scope): ObjectName = {
    // format object name with scope
    val scopedObjectName = "%s$%s".format(currentScope, objectName)

    // include object name with scope (according to the variable declarations)
    objectNamesScope = objectNamesScope.updated(objectName, currentScope)
    scopedObjectName
  }

  def findScopeForObjectName(rawObjectName: ObjectName, currentScope: Scope): ObjectName = {
    // trivial scopes (current function or global)
    val scopedVariable = objectNamesScope.getOrElse(rawObjectName, "GLOBAL")
    scopedVariable
  }

  def showAssignments() = {
    println("*** Assignments: %s".format(objectNameAssignments))
  }

  def showExtractedObjectNames() = {
    println(objectNames)
  }

  def showFunctionDefReturns() = {
    println(functionDefReturns)
  }

  def showFunctionDefs() = {
    println("*** Function defs (%d): %s".format(functionDefs.toPlainSet().size, functionDefs.toPlainSetWithConditionals()))
  }

  def showFunctionDefsParameters() = {
    println(functionDefParameters)
  }

  def showPointerEquivalenceClasses() = {
    equivalenceClasses.map(println)
  }

  def showFunctionCalls() = {
    println("*** Function calls (%d): %s".format(functionCalls.toPlainSet().size, functionCalls.toPlainSetWithConditionals()))
  }

  def showCallGraphStatistics() = {
    println("\nCall graph statistics: \n\tNodes: %d\n\tEdges: %d\n\tIndirect edges: %d\n\tNon-resolved edges: %d\n".format(callGraphNodes.toPlainSet().size, callGraphEdges.toPlainSet().size, callGraphEdges.toPlainSetWithConditionals.filter({ case (e, _) => e.kind.equals(EdgeKind.Indirect.toString) }).size, callGraphEdges.toPlainSetWithConditionals.filter({ case (e, _) => e.kind.equals(EdgeKind.FunctionNameNotFound.toString) || e.kind.equals(EdgeKind.EquivalenceClassNotFound.toString) }).size))
  }

  def showCallGraph() = {
    println("\nCall graph: \n\tNodes: %s\n\tEdges: %s\n\tIndirect edges: %s\n\tNon-resolved edges: %s\n".format(callGraphNodes.toPlainSet(), callGraphEdges.toPlainSet(), callGraphEdges.toPlainSetWithConditionals.filter({ case (e, _) => e.kind.equals(EdgeKind.Indirect.toString) }), callGraphEdges.toPlainSetWithConditionals.filter({ case (e, _) => e.kind.equals(EdgeKind.FunctionNameNotFound.toString) || e.kind.equals(EdgeKind.EquivalenceClassNotFound.toString) })))
  }

  // foe debugging purposes, invalid edges (FNNF and ECNF) are kept in the final graph
  def writeDbgCallGraph(fileName: String, writer: GraphWriter, fm: FeatureModel = FeatureExprFactory.empty) = {
    callGraphNodes.toPlainSetWithConditionals().map({ case (Node(name, kind, line), expr) =>
      if (expr.isSatisfiable(fm)) writer.writeNode(name, kind, line, expr)
    })
    callGraphEdges.toPlainSetWithConditionals().foreach({ case (Edge(src, dst, kind), expr) =>
      if (expr.isSatisfiable(fm)) writer.writeEdge(src, dst, kind, expr)
    })
    writer.close()
  }

  // invalid edges (FNNF and ECNF) are removed from final call graph
  def writeCallGraph(fileName: String, writer: GraphWriter, fm: FeatureModel = FeatureExprFactory.empty) = {
    callGraphNodes.toPlainSetWithConditionals().map({ case (Node(name, kind, line), expr) =>
      if (expr.isSatisfiable(fm)) writer.writeNode(name, kind, line, expr)
    })
    callGraphEdges.filterNot({ e: Edge => e.kind.equals("FNNF") || e.kind.equals("ECNF") }).toPlainSetWithConditionals().foreach({ case (Edge(src, dst, kind), expr) =>
      if (expr.isSatisfiable(fm)) writer.writeEdge(src, dst, kind, expr)
    })
    writer.close()
  }

  def writeDotCallGraph(fileName: String, writer: GraphWriter, fm: FeatureModel = FeatureExprFactory.empty) = {
    writer.writeHeader(fileName)
    callGraphNodes.toPlainSetWithConditionals().map({ case (Node(name, kind, line), expr) =>
      if (expr.isSatisfiable(fm)) writer.writeNode(name, kind, line, expr)
    })
    callGraphEdges.filterNot({ e: Edge => e.kind.equals("FNNF") || e.kind.equals("ECNF") }).toPlainSetWithConditionals().foreach({ case (Edge(src, dst, kind), expr) =>
      if (expr.isSatisfiable(fm)) writer.writeEdge(src, dst, kind, expr)
    })
    writer.writeFooter()
    writer.close()
  }


  def parenthesize(objName: String) = {
    if (ObjectNameOperator.values.toList.map({ op => op.toString }).exists(objName.contains)) {
      "(%s)".format(objName)
    }
    else objName
  }

  private def extractExpr(expr: Expr, ctx: FeatureExpr): Option[String] = {
    if (DEBUG) {
      println(expr)
    }
    expr match {
      case Id(name: String) => Some(name)
      // constants are not important
      case Constant(value: String) => None
      case StringLit(name: List[Opt[String]]) => None
      case UnaryExpr(kind: String, e: Expr) => extractExpr(e, ctx)
      case SizeOfExprT(typeName: TypeName) => None
      case SizeOfExprU(expr: Expr) => extractExpr(expr, ctx)
        None
      case CastExpr(typeName: TypeName, expr: Expr) => {
        val exprStr = extractExpr(expr, ctx)
        exprStr
      }
      case ExprList(exprs: List[Opt[Expr]]) => {
        functionCallParamList = List()
        for (Opt(fExpr, e) <- exprs) {
          val exprStr = extractObjectNames(e, ctx and fExpr);
          if (exprStr.isDefined) {
            val scope = findScopeForObjectName(exprStr.get, currentFunction)
            functionCallParamList = functionCallParamList :+ Opt(ctx and fExpr, applyScope(exprStr.get, scope))
          }
        }
        None
      };

      case PointerDerefExpr(castExpr: Expr) => {
        val exprStr = extractExpr(castExpr, ctx)
        if (exprStr.isDefined) {

          val scope = findScopeForObjectName(exprStr.get, currentFunction)

          val objectName1 = applyScope(exprStr.get, scope)
          val objectName2 = applyScope((ObjectNameOperator.PointerDereference.toString + parenthesize(exprStr.get)), scope)

          addObjectName(objectName1, ctx)
          addObjectName(objectName2, ctx)
          addPrefixSet(objectName2, objectName1)
        }
        exprStr.map(ObjectNameOperator.PointerDereference.toString + parenthesize(_))
      }
      case PointerCreationExpr(castExpr: Expr) => {
        val exprStr = extractExpr(castExpr, ctx)
        if (exprStr.isDefined) {
          val scope = findScopeForObjectName(exprStr.get, currentFunction)

          val objectName1 = applyScope(exprStr.get, scope)
          val objectName2 = applyScope((ObjectNameOperator.PointerCreation.toString + parenthesize(exprStr.get)), scope)

          addObjectName(objectName1, ctx)
          addObjectName(objectName2, ctx)
          addPrefixSet(objectName2, objectName1)

        }
        exprStr.map(ObjectNameOperator.PointerCreation.toString + parenthesize(_))

      }
      case UnaryOpExpr(kind: String, castExpr: Expr) => extractExpr(castExpr, ctx)

      // any kind of pointer arithmetic or comparison is ignored by analysis
      case NAryExpr(expr: Expr, others: List[Opt[NArySubExpr]]) => {
        val exprStr = extractExpr(expr, ctx)
        if (exprStr.isDefined) {
          val scope = findScopeForObjectName(exprStr.get, currentFunction)
          addObjectName(applyScope(exprStr.get, scope), ctx)
        }
        for (Opt(fExpr, subExpr) <- others) extractObjectNames(subExpr, ctx and fExpr)
        exprStr
      }

      case ConditionalExpr(condition: Expr, thenExpr: Option[Expr], elseExpr: Expr) => {
        extractExpr(condition, ctx)
        var exprStr1: Option[String] = None
        val exprStr2 = extractExpr(elseExpr, ctx)

        if (thenExpr.isDefined) {
          exprStr1 = extractExpr(thenExpr.get, ctx)
        }
        Some(exprStr1.getOrElse("Empty") + "|" + exprStr2.getOrElse("Empty"))
      }

      case AssignExpr(target: Expr, operation: String, source: Expr) => {
        val exprStr1 = extractExpr(target, ctx)
        val exprStr2 = extractExpr(source, ctx)
        if (exprStr1.isDefined && exprStr2.isDefined) {
          val scopeObj1 = findScopeForObjectName(exprStr1.get, currentFunction)
          val scopeObj2 = findScopeForObjectName(exprStr2.get, currentFunction)

          val objName1 = addObjectName(applyScope(exprStr1.get, scopeObj1), ctx)
          val objName2 = addObjectName(applyScope(exprStr2.get, scopeObj2), ctx)

          // object names and context (disjunction of both subexpressions)
          objectNameAssignments +=((objName1, objName2), ctx)
        }
        exprStr2
      }
      case PostfixExpr(postFixExpr: Expr, suffixExpr: PostfixSuffix) => {
        val exprStr1 = extractExpr(postFixExpr, ctx)
        val exprStr2 = extractObjectNames(suffixExpr, ctx)

        // member access operators
        if (exprStr1.isDefined && exprStr2.isDefined) {
          val scope = findScopeForObjectName(exprStr1.get, currentFunction)

          // -> (sctruct pointer access operator)
          if (exprStr2.get startsWith ObjectNameOperator.StructPointerAccess.toString) {
            val objectName1 = applyScope(exprStr1.get, scope)
            val objectName2 = applyScope(ObjectNameOperator.PointerDereference.toString + parenthesize(exprStr1.get), scope)
            val objectName3 = applyScope(parenthesize(exprStr1.get) + exprStr2.get, scope)

            addObjectName(objectName1, ctx)
            addObjectName(objectName2, ctx)
            addObjectName(objectName3, ctx)

            addPrefixSet(objectName3, objectName2)

            // . (struct access operator)
          } else if (exprStr2.get startsWith ObjectNameOperator.StructAccess.toString) {
            val objectName1 = applyScope(exprStr1.get, scope)
            val objectName2 = applyScope(parenthesize(exprStr1.get) + exprStr2.get, scope)

            addObjectName(objectName1, ctx)
            addObjectName(objectName2, ctx)

            addPrefixSet(objectName2, objectName1)

          }

          // array access
          else if (exprStr2.get equals ObjectNameOperator.ArrayAccess.toString) {
            addObjectName(applyScope(parenthesize(exprStr1.get) + exprStr2.get, scope), ctx)
          }

          // is a function call?
          else if (exprStr2.get equals ObjectNameOperator.FunctionCall.toString) {
            functionCallParameters +:=(exprStr1.get, functionCallParamList)
            functionCalls = functionCalls.+((currentFunction, exprStr1.get), ctx)

            addObjectName(applyScope(exprStr1.get + ObjectNameOperator.FunctionCall.toString, currentFunction), ctx)
          }
        }
        exprStr1.flatMap(e1 => exprStr2.map(e2 => parenthesize(e1) + e2))
      };
      case CompoundStatementExpr(compoundStatement: CompoundStatement) => extractStmt(compoundStatement, ctx)
      case BuiltinOffsetof(typeName: TypeName, offsetofMemberDesignator: List[Opt[OffsetofMemberDesignator]]) => None
      case BuiltinTypesCompatible(typeName1: TypeName, typeName2: TypeName) => None
      case BuiltinVaArgs(expr: Expr, typeName: TypeName) => None
      case LcurlyInitializer(inits: List[Opt[Initializer]]) => ; None
      case AlignOfExprT(typeName: TypeName) => extractObjectNames(typeName, ctx);
      case AlignOfExprU(expr: Expr) => extractExpr(expr, ctx);
      case GnuAsmExpr(isVolatile: Boolean, isGoto: Boolean, expr: StringLit, stuff: Any) => extractExpr(expr, ctx);
      case RangeExpr(from: Expr, to: Expr) => extractExpr(from, ctx); extractExpr(to, ctx); None

    }

  }

  private def extractStmt(stmt: Statement, ctx: FeatureExpr): Option[String] = {
    if (DEBUG) {
      println(stmt)
    }
    stmt match {
      case CompoundStatement(innerStatements: List[Opt[Statement]]) => {
        for (Opt(fExpr, e) <- innerStatements) extractStmt(e, ctx and fExpr)
        None
      }
      case EmptyStatement() => None
      case ExprStatement(expr: Expr) => extractExpr(expr, ctx)
      case WhileStatement(expr: Expr, s: Conditional[Statement]) => {
        val exprStr = extractExpr(expr, ctx)
        if (exprStr.isDefined) {
          val scope = findScopeForObjectName(exprStr.get, currentFunction)
          addObjectName(applyScope(exprStr.get, scope), ctx)
        }
        s.vmap(ctx, (c, stmt) => extractStmt(stmt, c))
        None
      }
      case DoStatement(expr: Expr, s: Conditional[Statement]) => {
        val exprStr = extractExpr(expr, ctx)
        if (exprStr.isDefined) {
          val scope = findScopeForObjectName(exprStr.get, currentFunction)
          addObjectName(applyScope(exprStr.get, scope), ctx)
        }
        s.vmap(ctx, (c, stmt) => extractStmt(stmt, c))
        None
      }
      case ForStatement(expr1: Option[Expr], expr2: Option[Expr], expr3: Option[Expr], s: Conditional[Statement]) => {
        val expr1Str = extractExpr(expr1.getOrElse(new Constant("")), ctx)
        val expr2Str = extractExpr(expr2.getOrElse(new Constant("")), ctx)
        val expr3Str = extractExpr(expr3.getOrElse(new Constant("")), ctx)

        if (expr1Str.isDefined) {
          val scope = findScopeForObjectName(expr1Str.get, currentFunction)
          addObjectName(applyScope(expr1Str.get, scope), ctx)
        }
        if (expr2Str.isDefined) {
          val scope = findScopeForObjectName(expr2Str.get, currentFunction)
          addObjectName(applyScope(expr2Str.get, scope), ctx)
        }
        if (expr3Str.isDefined) {
          val scope = findScopeForObjectName(expr3Str.get, currentFunction)
          addObjectName(applyScope(expr3Str.get, scope), ctx)
        }

        s.vmap(ctx, (c, stmt) => extractStmt(stmt, c))
        None
      }
      case GotoStatement(target: Expr) => extractExpr(target, ctx);
        None
      case ContinueStatement() => None
      case BreakStatement() => None
      case ReturnStatement(expr: Option[Expr]) => {
        if (expr.isDefined) {
          val exprStr = extractExpr(expr.get, ctx)
          if (exprStr.isDefined) {
            val scope = findScopeForObjectName(exprStr.get, currentFunction)
            functionDefReturns = functionDefReturns.updated(currentFunction, functionDefReturns.getOrElse(currentFunction, ConditionalSet()) +(applyScope(exprStr.get, scope), ctx))
          }
        }
        None
      }
      case LabelStatement(id: Id, attribute: Option[AttributeSpecifier]) => None
      case CaseStatement(c: Expr) => extractExpr(c, ctx)
        None
      case DefaultStatement() => None
      case IfStatement(condition: Conditional[Expr], thenBranch: Conditional[Statement], elifs: List[Opt[ElifStatement]], elseBranch: Option[Conditional[Statement]]) => {

        for (Opt(fExpr, e) <- condition.toOptList) {
          val exprStr = extractExpr(e, ctx and fExpr)

          if (exprStr.isDefined) {
            val scope = findScopeForObjectName(exprStr.get, currentFunction)
            addObjectName(applyScope(exprStr.get, scope), ctx and fExpr)
          }
        }
        thenBranch.vmap(ctx, (c, stmt) => extractStmt(stmt, c))
        for (Opt(fExpr, s) <- elifs) extractObjectNames(s, ctx and fExpr)
        if (elseBranch.isDefined) elseBranch.get.vmap(ctx, (c, stmt) => extractStmt(stmt, c))
        None
      }

      case SwitchStatement(expr: Expr, s: Conditional[Statement]) => {
        extractExpr(expr, ctx)
        s.vmap(ctx, (c, stmt) => extractStmt(stmt, c))
        None
      }
      case DeclarationStatement(decl: Declaration) => {
        isDeclarationStatement = True
        val declStr = extractObjectNames(decl, ctx)
        isDeclarationStatement = False
        declStr
      }
      case LocalLabelDeclaration(ids: List[Opt[Id]]) => {
        for (Opt(fExpr, id) <- ids) extractExpr(id, ctx and fExpr)
        None
      }

      case NestedFunctionDef(isAuto: Boolean, specifiers: List[Opt[Specifier]], declarator: Declarator, parameters: List[Opt[Declaration]], stmt: CompoundStatement) => {
        isFunctionDef = True

        // initialize return and parameters list for function
        functionDefReturns += (declarator.getName -> ConditionalSet())
        functionDefParameters += (declarator.getName -> List[Opt[ObjectName]]())

        val oldObjectNamesScope = objectNamesScope
        val oldCurrentFunction = currentFunction
        isDeclarationStatement = True;

        // extract function definition information
        isFunctionDeclarator = True
        extractObjectNames(declarator, ctx)
        isFunctionDeclarator = False

        // update scope - current function
        currentFunction = declarator.getName
        currentFunctionKind = functionKind(specifiers)
        currentDeclaratorLine = declarator.getPositionFrom.getLine

        // replace old function declarations for complete definitions
        functionDefs = functionDefs.filterNot({ case (name, kind, _) => name.equals(currentFunction) && kind.equals("declaration") })

        // remove old function definition and use old function presence condition
        val oldFunctionDef = functionDefs.toPlainSetWithConditionals().find({ case ((name, kind, _), _) => name.equals(currentFunction) && kind.equals("function") })
        if (oldFunctionDef.isDefined) {
          val oldCtx = oldFunctionDef.map({ case ((name, kind, _), featExpr) => featExpr }).getOrElse(True)
          functionDefs = functionDefs.filterNot({ case (name, kind, _) => name.equals(currentFunction) && kind.equals("function") })
          functionDefs +=((currentFunction, currentFunctionKind, currentDeclaratorLine), ctx or oldCtx)
        } else {
          functionDefs +=((currentFunction, currentFunctionKind, currentDeclaratorLine), ctx)
        }
        // extract function parameters and body statements
        for (Opt(featExpr, p) <- parameters) extractObjectNames(p, ctx and featExpr)
        extractStmt(stmt, ctx)

        // end of function - restore global state
        isDeclarationStatement = False;
        isFunctionDef = False
        currentFunction = oldCurrentFunction
        objectNamesScope = oldObjectNamesScope

        None
      }
    }
  }

  private def extractDeclarator(declarator: AST, ctx: FeatureExpr): Option[String] = {
    if (DEBUG) {
      println(declarator)
    }
    declarator match {
      // variable declarator with initializer
      case InitDeclaratorI(decl: Declarator, _, init: Option[Initializer]) => {
        val declStr = extractObjectNames(decl, ctx)

        currentDeclarator = declStr.getOrElse("DECLARATOR_NOT_AVAILABLE")
        val initNames = init.flatMap(i => extractObjectNames(i, ctx))

        if (declStr.isDefined) {
          if (isNotTypedefSpecifier.isSatisfiable()) {
            val objName1 = addObjectName(applyScope(declStr.get, currentFunction), ctx)

            if (initNames.isDefined) {
              val scope = findScopeForObjectName(initNames.get, currentFunction)
              val objName2 = addObjectName(applyScope(initNames.get, scope), ctx)

              // assignment (no need to get a new presence condition, objet names already in the same context)
              objectNameAssignments +=((objName1, objName2), ctx)
            }
          }
          initNames
        } else None
      }

      // variable declarator
      case AtomicNamedDeclarator(pointers: List[Opt[Pointer]], id: Id, extensions: List[Opt[DeclaratorExtension]]) => {
        currentDeclarator = id.name
        currentDeclaratorLine = id.getPositionFrom.getLine
        isPointer = False

        for (Opt(featExpr, e) <- pointers) extractObjectNames(e, ctx and featExpr);

        if (isDeclarationStatement.isSatisfiable() && isNotTypedefSpecifier.isSatisfiable()) {
          addObjectName(applyScope(currentDeclarator, currentFunction), ctx)

          // consider pointers only on non-function declarators and function parameters
          if (isPointer.isSatisfiable() && isFunctionDeclarator.isContradiction()) {
            addObjectName(applyScope(ObjectNameOperator.PointerDereference.toString + parenthesize(id.name), currentFunction), ctx)
          }
        }
        for (Opt(featExpr, e) <- extensions) extractObjectNames(e, ctx and featExpr);

        Some(currentDeclarator)

      }

      case NestedNamedDeclarator(pointers: List[Opt[Pointer]], nestedDecl: Declarator, extensions: List[Opt[DeclaratorExtension]], attr: List[Opt[AttributeSpecifier]]) => {
        isPointer = False
        for (Opt(featExpr, e) <- pointers) extractObjectNames(e, ctx and featExpr)

        val declStr = extractObjectNames(nestedDecl, ctx)
        currentDeclarator = declStr.getOrElse("DECLARATOR_NOT_AVAILABLE")

        // for (Opt(featExpr, e) <- extensions) extractObjectNames(e, ctx and featExpr)
        // for (Opt(featExpr, e) <- attr) extractObjectNames(e, ctx and featExpr)
        declStr
      }
      case AtomicAbstractDeclarator(pointers: List[Opt[Pointer]], extensions: List[Opt[DeclaratorAbstrExtension]]) => {
        isPointer = False
        for (Opt(featExpr, e) <- pointers) extractObjectNames(e, ctx and featExpr)
        for (Opt(featExpr, e) <- extensions) extractObjectNames(e, ctx and featExpr)
        None
      }

      case NestedAbstractDeclarator(pointers: List[Opt[Pointer]], nestedDecl: AbstractDeclarator, extensions: List[Opt[DeclaratorAbstrExtension]], attr: List[Opt[AttributeSpecifier]]) => {
        isPointer = False
        for (Opt(featExpr, e) <- pointers) extractObjectNames(e, ctx and featExpr)
        val declStr = extractObjectNames(nestedDecl, ctx)

        // for (Opt(featExpr, e) <- extensions) extractObjectNames(e, ctx and featExpr)
        // for (Opt(featExpr, e) <- attr) extractObjectNames(e, ctx and featExpr)
        declStr
      }
    }

  }

  def extractObjectNames(ast: AST, ctx: FeatureExpr): Option[String] = {
    if (DEBUG) {
      println(ast)
    }
    ast match {
      case EmptyExternalDef() => None
      case TypeName(specifiers: List[Opt[Specifier]], decl: Option[AbstractDeclarator]) => {
        for (Opt(featExpr, s) <- specifiers) extractObjectNames(s, ctx and featExpr)
        if (decl.isDefined) extractObjectNames(decl.get, ctx)
        None
      }
      case TranslationUnit(list: List[Opt[ExternalDef]]) => for (Opt(featExpr, e) <- list) extractObjectNames(e, ctx and featExpr); None

      case Declaration(declSpecs: List[Opt[Specifier]], init: List[Opt[InitDeclarator]]) => {
        isDeclarationStatement = True
        isNotTypedefSpecifier = True;
        for (Opt(featExpr, e) <- declSpecs) extractObjectNames(e, ctx and featExpr)
        declSpecs.map {
          case Opt(featExpr, t: TypedefSpecifier) => isNotTypedefSpecifier = isNotTypedefSpecifier andNot featExpr;
          case _ =>
        }

        // select potential function kind for declaration
        currentFunctionKind = functionKind(declSpecs)

        for (Opt(featExpr, e) <- init) extractObjectNames(e, ctx and featExpr)
        isDeclarationStatement = False;
        None
      }

      case AsmExpr(isVolatile: Boolean, expr: Expr) => {
        extractExpr(expr, ctx)
      }

      case TypelessDeclaration(declList: List[Opt[InitDeclarator]]) => {
        for (Opt(featExpr, decl) <- declList) extractObjectNames(decl, ctx and featExpr)
        None
      }

      case FunctionCall(exprList: ExprList) => {
        extractExpr(exprList, ctx)

        Some(ObjectNameOperator.FunctionCall.toString)
      };
      /*
       * TODO: analyze function defs and calls to relate parameters
       *
       */
      case SimplePostfixSuffix(t: String) => None
      case PointerPostfixSuffix(operator: String, expr) => {
        val str = extractExpr(expr, ctx)
        str.map(operator + _)
      }

      case specif: Specifier => None
      case ArrayAccess(expr: Expr) => Some(ObjectNameOperator.ArrayAccess.toString)

      // ignore any kind of subexpression (with exception of assignments)
      case NArySubExpr(op: String, e: Expr) => {
        e match {
          case a: AssignExpr => extractExpr(a, ctx);
          case fc: PostfixExpr => extractExpr(fc, ctx);
          case ne: NAryExpr => extractExpr(ne, ctx)
          case _ => ;
        }
        None
      }

      case FunctionDef(specifiers: List[Opt[Specifier]], declarator: Declarator, parameters: List[Opt[OldParameterDeclaration]], stmt: CompoundStatement) => {
        isFunctionDef = True

        // initialize return and parameters list for function
        functionDefReturns += (declarator.getName -> ConditionalSet())
        functionDefParameters += (declarator.getName -> List[Opt[ObjectName]]())

        val oldObjectNamesScope = objectNamesScope
        isDeclarationStatement = True;

        // extract function definition information
        isFunctionDeclarator = True
        extractObjectNames(declarator, ctx)
        isFunctionDeclarator = False

        // update scope - current function
        currentFunction = declarator.getName
        currentFunctionKind = functionKind(specifiers)
        currentDeclaratorLine = declarator.getPositionFrom.getLine

        // replace old function declarations for complete definitions (with updated context)
        functionDefs = functionDefs.filterNot({ case (name, kind, _) => name.equals(currentFunction) && kind.equals("declaration") })

        // remove old function definition and use old function presence condition
        val oldFunctionDef = functionDefs.toPlainSetWithConditionals().find({ case ((name, kind, _), _) => name.equals(currentFunction) && kind.equals("function") })
        if (oldFunctionDef.isDefined) {
          val oldCtx = oldFunctionDef.map({ case ((name, kind, _), featExpr) => featExpr }).getOrElse(True)
          functionDefs = functionDefs.filterNot({ case (name, kind, _) => name.equals(currentFunction) && kind.equals("function") })
          functionDefs +=((currentFunction, currentFunctionKind, currentDeclaratorLine), ctx or oldCtx)
        } else {
          functionDefs +=((currentFunction, currentFunctionKind, currentDeclaratorLine), ctx)
        }

        // extract function parameters and body statements
        for (Opt(featExpr, p) <- parameters) extractObjectNames(p, ctx and featExpr)
        extractStmt(stmt, ctx)

        // end of function - restore global state
        isDeclarationStatement = False
        isFunctionDef = False
        currentFunction = "GLOBAL"
        objectNamesScope = oldObjectNamesScope

        None
      }

      case DeclIdentifierList(idList: List[Opt[Id]]) => {
        // add declarator name for current function
        val previousFunction = currentFunction
        currentFunction = currentDeclarator

        // if it is a function declaration
        val funcDef = functionDefs.toPlainSet().filter({ case (name, kind, _) => name.equals(currentFunction) && (kind.equals("function") || kind.equals("declaration")) })
        if (funcDef.isEmpty) {
          functionDefs +=((currentFunction, "declaration", currentDeclaratorLine), ctx)
        }
        for (Opt(fExpr, e) <- idList) extractObjectNames(e, fExpr);
        currentFunction = previousFunction

        None
      }

      // function parameters declaration
      // captures parameters for FunctionDef, Extern declarations, Typedefs definitions
      case DeclParameterDeclList(parameterDecls: List[Opt[ParameterDeclaration]]) => {
        isDeclarationStatement = True

        // add declarator name for current function
        val previousFunction = currentFunction
        currentFunction = currentDeclarator

        // if it is a function declaration
        val funcDef = functionDefs.toPlainSet().filter({ case (name, kind, _) => name.equals(currentFunction) && (kind.equals("function") || kind.equals("declaration")) })
        if (funcDef.isEmpty) {
          functionDefs +=((currentFunction, "declaration", currentDeclaratorLine), ctx)
        }

        // add function as object name
        val scopedFunctionName = applyScope(currentDeclarator, "GLOBAL")
        addObjectName(scopedFunctionName, ctx)

        isFunctionDeclarator = False
        // iterate over parameters extracting object names
        for (Opt(featExpr, e) <- parameterDecls) extractObjectNames(e, ctx and featExpr);
        isFunctionDeclarator = True
        currentFunction = previousFunction
        isDeclarationStatement = False
        None
      }

      case DeclArrayAccess(expr: Option[Expr]) => {
        if (expr.isDefined) {
          val exprStr = extractExpr(expr.get, ctx)
          exprStr
        }
        else None
      }

      case PlainParameterDeclaration(declSpecs: List[Opt[Specifier]], attr: List[Opt[AttributeSpecifier]]) => {
        for (Opt(featExpr, e) <- declSpecs) extractObjectNames(e, ctx and featExpr)
        isNotTypedefSpecifier = True
        declSpecs.map {
          case Opt(featExpr, ts: TypedefSpecifier) => isNotTypedefSpecifier = isNotTypedefSpecifier andNot featExpr;
          case _ =>
        }
        for (Opt(_, e) <- attr) extractObjectNames(e, ctx)

        None
      }

      case ParameterDeclarationD(declSpecs: List[Opt[Specifier]], decl: Declarator, attr: List[Opt[AttributeSpecifier]]) => {
        for (Opt(featExpr, e) <- declSpecs) extractObjectNames(e, ctx and featExpr)

        isNotTypedefSpecifier = True
        declSpecs.map {
          case Opt(featExpr, ts: TypedefSpecifier) => isNotTypedefSpecifier = isNotTypedefSpecifier andNot featExpr;
          case _ =>
        }

        val declStr = extractObjectNames(decl, ctx)
        if (isDeclarationStatement.isSatisfiable() && declStr.isDefined) {

          objectNamesScope = objectNamesScope.updated(declStr.get, currentFunction)
          functionDefParameters = functionDefParameters.updated(currentFunction, functionDefParameters.getOrElse(currentFunction, List[Opt[ObjectName]]()) :+ Opt(ctx, applyScope(declStr.get, currentFunction)))

          if (isPointer.isSatisfiable()) {
            val pointerObjectName = ObjectNameOperator.PointerDereference.toString + parenthesize(declStr.get)
            objectNamesScope = objectNamesScope.updated(pointerObjectName, currentFunction)
          }
        }

        for (Opt(featExpr, e) <- attr) extractObjectNames(e, ctx and featExpr)

        declStr
      }

      case ParameterDeclarationAD(declSpecs: List[Opt[Specifier]], decl: AbstractDeclarator, attr: List[Opt[AttributeSpecifier]]) => {
        for (Opt(featExpr, e) <- declSpecs) extractObjectNames(e, ctx and featExpr)
        isNotTypedefSpecifier = True
        declSpecs.map {
          case Opt(featExpr, ts: TypedefSpecifier) => isNotTypedefSpecifier = isNotTypedefSpecifier andNot featExpr;
          case _ =>
        }

        for (Opt(featExpr, e) <- attr) extractObjectNames(e, ctx and featExpr)
        val declStr = extractObjectNames(decl, ctx)
        if (isDeclarationStatement.isSatisfiable() && declStr.isDefined) {
          objectNamesScope = objectNamesScope.updated(declStr.get, currentFunction)
        }
        declStr
      }

      case Initializer(initializerElementLabel: Option[InitializerElementLabel], expr: Expr) => {
        val exprStr = extractExpr(expr, ctx)
        exprStr
      }

      case Pointer(specifier: List[Opt[Specifier]]) => {
        isPointer = True
        None
      }

      case AtomicAttribute(n: String) => {
        Some(n)
      }

      case AttributeSequence(attributes: List[Opt[Attribute]]) => {
        for (Opt(featExpr, e) <- attributes) extractObjectNames(e, ctx and featExpr)
        None
      }

      case CompoundAttribute(inner: List[Opt[AttributeSequence]]) => {
        for (Opt(featExpr, e) <- inner) extractObjectNames(e, ctx and featExpr)
        None
      }

      case ElifStatement(condition: Conditional[Expr], thenBranch: Conditional[Statement]) => {
        val exprStr = condition match {
          case One(e) => extractExpr(e, ctx)
          case Choice(e, thenBranch, elseBranch) => {
            val thenStr = thenBranch.map(expr => extractExpr(expr, ctx and e))

            val elseStr = elseBranch.map(expr => extractExpr(expr, ctx andNot e))
            None
          }
        }
        if (exprStr.isDefined) {
          val scope = findScopeForObjectName(exprStr.get, currentFunction)
          addObjectName(applyScope(exprStr.get, scope), ctx)
        }
        thenBranch.map(stmt => extractStmt(stmt, ctx))
        exprStr
      }

      case va: VarArgs => None
      case p: Pragma => None
      case e: Expr => extractExpr(e, ctx)
      case s: Statement => extractStmt(s, ctx)
      case d: Declarator => extractDeclarator(d, ctx)
      case ad: AbstractDeclarator => extractDeclarator(ad, ctx)
      case id: InitDeclarator => extractDeclarator(id, ctx)
      case z => throw new RuntimeException("%s is not supported".format(z.getClass))
    }
  }
}

abstract class Graph

case class Node(label: String, kind: String, sourceCodeLine: Int) extends Graph

case class Edge(source: String, destination: String, kind: String) extends Graph

object ObjectNameOperator extends Enumeration {
  type Operator = Value
  val StructPointerAccess = Value("->")
  val PointerDereference = Value("*")
  val PointerCreation = Value("&")
  val StructAccess = Value(".")
  val FunctionCall = Value("()")
  val ArrayAccess = Value("[]")
}

object EdgeKind extends Enumeration {
  type EdgeKind = Value
  val EquivalenceClassNotFound = Value("ECNF")
  val FunctionNameNotFound = Value("FNNF")
  val Direct = Value("D")
  val Indirect = Value("I")
}